\newif\ifcomments     %% include author discussion
\newif\ifanonymous    %% include author identities
\newif\ifextended     %% include appendix
\newif\ifsubmission   %% prepare the submitted version
\newif\ifpublic       %% version available for posting / final version

\documentclass[acmsmall, nonacm=true]{acmart}

% \setcopyright{rightsretained}
% \acmDOI{}
% \acmYear{2025}
% \copyrightyear{2025}
% \acmSubmissionID{}
% \acmJournal{PACMPL}
% \acmVolume{}
% \acmNumber{POPL}
% \acmArticle{}
% \acmMonth{}
% \received{}
% \received[accepted]{}

\let\Bbbk\relax
\usepackage{draft} % local
\usepackage[supertabular]{ottalt} % local
\let\newlist\relax
\let\renewlist\relax
\usepackage{enumitem}
\usepackage{amsmath,amssymb}
\usepackage{natbib}
\usepackage{mathpartir,mathtools,stmaryrd}
\usepackage{todonotes,listings,xspace,color,tcolorbox,doi}
\usepackage[flushmargin,multiple,para]{footmisc}
\usepackage[noend]{algpseudocode}
\usepackage[capitalize,noabbrev,nameinlink]{cleveref}

\citestyle{acmauthoryear}

\hypersetup{
  colorlinks=true,
  urlcolor=blue,
  citecolor=violet
}

\lstset{
  basicstyle=\ttfamily\small,
  basewidth=0.5em,
  aboveskip=0pt,
  belowskip=0pt,
  basicstyle=\ttfamily,
  columns=fixed,
  mathescape=true,
  breaklines=false,
  morekeywords={data,where,case,of},
  morecomment=[l][\color{gray}]--,
  literate=
    {->}{{$\mathrel{\rightarrow}$}}2
    {\\}{{$\lambda$}}1
    {=>}{{$\mathrel{\Rightarrow}$}}2
    {~}{{=}}1
}

\ifcomments
\newnote{sw}{blue} % Stephanie Weirich
\newnote{yl}{purple} % Yiyun Liu
\newnote{jc}{olive} % Jonathan Chan
\else
\newcommand{\sw}[1]{}
\newcommand{\yl}[1]{}
\newcommand{\jc}[1]{}
\fi

\DeclarePairedDelimiter{\bracks}{\llbracket}{\rrbracket}
\DeclarePairedDelimiter{\braces}{\lbrace}{\rbrace}

\newcommand{\suppress}[1]{}
\newcommand{\dcoi}{DCOI\@\xspace}
\newcommand{\name}{\texorpdfstring{DCOI$^{\omega}$\@\xspace}{DCOI-omega}}
\newcommand{\longname}{Dependent Calculus of Indistinguishability\@\xspace}
\newcommand{\ie}{\textit{i.e.}\@\xspace}
\newcommand{\eg}{\textit{e.g.}\@\xspace}
\newcommand{\apriori}{\textit{a priori}\@\xspace}
\newcommand{\aposteriori}{\textit{a posteriori}\@\xspace}
\newcommand{\suppl}[3]{{\scriptsize\texttt{#2:#3}}}
\newcommand{\judgement}[1]{{\setlength{\fboxsep}{1.5pt}\fbox{#1}}}
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$#2$}}
\newcommand{\hlcolor}{yellow}
\newcommand{\repo}{%
  \ifpublic our public repository at \jc{TODO: replace with repo URL}%
  \else the supplementary materials%
  \fi
}

\newcommand{\interp}[4]{\bracks{#1 \vDash_{#2} #3} \searrow #4}
\newcommand{\interpU}[3]{\bracks{#1 \vDash_{#2} #3}}
\newcommand{\buildset}[3]{#2 . \braces{#1 \mid #3}}
\newcommand{\member}[3]{#1 \in #3(#2)}
\newcommand{\dom}{\mathop{\mathsf{dom}}}
\newcommand{\sws}[3]{#1 \vDash #2 : #3}
\newcommand{\swt}[4]{#1 \vDash #2 :^{#3} #4}
\newcommand{\swf}[1]{\vDash #1}
\newcommand{\prodspace}[5]{#1 \in \hat{\Pi}(#2^{#3}, #4^{#5})}
\newcommand{\sigspace}[5]{#1 \in \hat{\Sigma}(#2^{#3}, #4^{#5})}
\newcommand{\univspace}[1]{\hat{\mathcal{U}}_{#1}}
\newcommand{\eqspace}[5]{#1 \in (#2 \vdash #3 \mathrel{\hat{=}}^{#5} #4)}

\newlength{\punctwidth}
% \punctstack{<punct>} treats <punct> as having no width,
% so that footnotes after it can stack on top
\newcommand{\punctstack}[1]{#1%
  \settowidth{\punctwidth}{#1}%
  \hspace*{-\the\punctwidth}%
}
% \stack{<punct>} is a negative space the size of <punct>
% to manually stack existing punctuation and footnotes
% atop one another; essentially \punctstack without the punct
\newcommand{\stack}[1]{%
  \settowidth{\punctwidth}{#1}%
  \hspace*{-\the\punctwidth}%
}

% reduce spacing surrounding captions
\setlength\abovecaptionskip{1pt plus 1pt minus 1pt}
\setlength\belowcaptionskip{1pt plus 1pt minus 1pt}

% reduce spacing surrounding figures
\setlength{\intextsep}{6pt plus 2pt minus 2pt}
\setlength{\textfloatsep}{6pt plus 2pt minus 2pt}

% \inputott{dcoi-rules}

\title{Strong normalization for F$\omega$ in Coq}

\author{Yiyun Liu}
\orcid{0009-0006-8717-2498}
\affiliation{%
  \institution{University of Pennsylvania}
  \city{Philadelphia}
  \country{USA}
}
\email{liuyiyun@seas.upenn.edu}

%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Liu et al.}

\begin{document}

\begin{abstract}
  Abstract
\end{abstract}

\maketitle

% \appendix

\section{Introduction}
Type level computation + impredicativity pose a different set of challenges.

\section{Curry-style System F$\omega$}
In this section, we review the syntax, operational semantics, and
typing rules of F$\omega$.

The syntax of kinds, type constructors, and terms can be found in Figure~\ref{fig:syntax}.
We choose to present F$\omega$ in
curry-style, meaning that for all quantifications are implicit in the
term syntax. % For example, in curry-style System F$\omega$, the lambda
% term $\lambda x . x$ can be ascribed the type $\forall \alpha . \alpha
% \rightarrow \alpha$. In church-style System F$\omega$, the same type
% is inhabited by the term $\Lambda \alpha. \lambda x : \alpha . x$,
% where the quantification over the type $\alpha$ explicitly appears in
% the term syntax.
% We present our system in curry-style to simplify the definitions of
% renaming and substitution; a church-style representation would require
% us to additionally define the operation to substitute type constructors into
% terms.

The notion of kinds allows us to specify when a type constructor is
well-formed. The kind $\star$ represents our usual notion of
types. The kind $k_0 \rightarrow k_1$ represents a type-level
computation that takes a constructor of kind $k_0$ and returns a
constructor of kind $k_1$. For example, the polymorphic list
constructor in Haskell and OCaml can be ascribed the kind $\star
\rightarrow \star$; when given some type $A$, it returns another type that
represents lists containing elements of type $A$.

The term syntax of F$\omega$ is identical to that of the pure untyped
lambda calculus. The terms $b\ a$ and $\lambda x . a$ stand for
applications and abstractions respectively.
The same constructs are mirrored in the syntax for constructors, where $B\ A$ and
$\Lambda \alpha . A$ are applications and abstractions at the
type-level. The arrow type $A \rightarrow B$ can be ascribed to
term-level functions. The for all type $\forall \alpha : k . A$ allows
us to define polymorphic functions that abstract over
constructors. When $k$ is instantiated to $\star$, we recover the more
limited type of quantification in System F, where we can only abstract
a term over types, but not arbitrary type-level computations.

The reduction rules for constructors and terms can be found in
Figure~\ref{fig:opsem}. Thanks to the Curry-style representation, we
can define the operational semantics for constructors and terms
independently since constructors never appear in the term syntax. The
operational semantics for terms and constructors are similar, though
the semantics of constructors additionally include congruence rules
for forall types and arrow types.

Typing for System F$\omega$ requires two judgment forms: the
well-formedness of constructors (Figure~\ref{fig:tywt}) and the
well-typedness of terms (Figure~\ref{fig:wt}).
The well-formedness judgment takes the form $\Delta \vdash A \in k$,
where $\Delta$, which we refer to as the kinding context, is a finite
map from constructor variables to kinds.

\section{Strong normalization}
In this section, we prove that every well-typed F$\omega$ terms are
strongly normalizing with a logical relation. Following
\citet{abel:poplmark}, we inductively characterize the set of strongly
normalizing terms through the judgments in Figure~\ref{fig:sn}. From
the definitions in Figure~\ref{fig:sn}, we define the notion of
saturated sets, which is necessary for interpreting the forall type.


To define a logical relation, we need to define a function that
interprets each type to a set of terms. However, in F$\omega$, types
may appear in the form of $B\ A$, where $B$ and $A$ are
constructors. As a result, we need to generalize the domain of our
interpretation function to include constructors of different kinds.

We start by defining the interpretation of kinds and higher-order
candidate space.
TODO:



% However, the presence of
% impredicativity and type-level computation makes the definition of the
% logical relation difficult.

% Type-level computation prevents us from defining the logical relation
% as a simple recursive function over raw constructors since
% constructors of the form $(\Lambda \alpha : k . \alpha\ \alpha)
% (\Lambda \alpha : k . \alpha\ \alpha)$



\section{Parametricity}


\section{Eliminating extensionality axioms}

\section{Discussion and Related Work}

\subsection{Syntactic logical relation for predicative type systems}


\end{document}
